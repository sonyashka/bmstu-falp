; задание 1 - done
; (defun palyndrom-lst (lst) (equal lst (reverse lst)))
; (print (palyndrom-lst '(a b c (d e) c b a)))
; задание 2 - done
; (defun set-size (sett &optional (size 0))
;     (cond ((null sett) size)
;           (t (set-size (cdr sett) (+ size 1)))))
; ; (print (set-size '(a b c d (e f))))
; (defun get-i-element (lst ind &optional (cur-ind 0)) 
;     (cond ((null lst) Nil)
;           ((= ind cur-ind) (car lst))
;           (t (get-i-element (cdr lst) ind (+ cur-ind 1)))))
; ; (print (get-i-element '(a b c (d e) f) 3))
; (defun set-include (set1 set2 &optional (ind2 0))
;     (cond ((= ind2 (set-size set2)) Nil)
;           ((null set1) t)
;           ((equalp (car set1) (get-i-element set2 ind2)) (set-include (cdr set1) set2 0))
;           (t (set-include set1 set2 (+ ind2 1)))))
; (defun set-equal (set1 set2) (and (= (set-size set1) (set-size set2))
;     (set-include set1 set2) (set-include set2 set1)))
; (print (set-equal '(a b d (c e)) '((c e) d a b)))
; задание 3 - done
; (defun find-capital (lst country)
;     (cond ((null lst) Nil)
;           ((equal (caar lst) country) (cdar lst))
;           (t (find-capital (cdr lst) country))))
; (defun find-country (lst capital)
;     (cond ((null lst) Nil)
;           ((equal (cdar lst) capital) (caar lst))
;           (t (find-country (cdr lst) capital))))
; (print (find-capital '(("Россия" . "Москва") ("Великобритания" . "Лондон")
;     ("Япония" . "Токио") ("Украина" . "Киев")) "Украина"))
; (print (find-country '(("Россия" . "Москва") ("Великобритания" . "Лондон")
;     ("Япония" . "Токио") ("Украина" . "Киев")) "Токио"))  
; ; задание 4 - done
; (defun remove-last (lst)
;     (cond ((or (null lst) (null (cdr lst))) Nil)
;           (t (reverse (cdr (reverse lst))))))
; (defun swap-first-last (lst)
;     (cond ((null lst) Nil)
;           ((null (cdr lst)) lst)
;           (t (cons (car (last lst)) (append (cdr (remove-last lst)) (cons (car lst) Nil))))))
; (print (swap-first-last '(a b c d)))
; задание 5 - done
; (defun swap-two-element (lst ind1 ind2 &optional (cnt 0) elem1)
;     (cond ((null lst) Nil)
;           ((= ind1 ind2) lst)
;           ((< ind2 ind1) (swap-two-element lst ind2 ind1))
;           (t (cond ((or (< cnt ind1) (< ind1 cnt ind2)) 
;                         (cons (car lst) (swap-two-element (cdr lst) ind1 ind2 (+ cnt 1) elem1)))
;                    ((= cnt ind1) 
;                         (cons (nth (- ind2 cnt) lst) (swap-two-element (cdr lst) ind1 ind2 (+ cnt 1) (car lst))))
;                    ((= cnt ind2)
;                         (cons elem1 (nthcdr (+ (- ind2 cnt) 1) lst)))
;              ))
;     ))
; (print (swap-two-element '(a b c (d e) f) 3 1))
; (print (swap-two-element '(a b c) 0 1))
; задание 6 - done
; (defun remove-last (lst)
;     (cond ((or (null lst) (null (cdr lst))) Nil)
;           (t (reverse (cdr (reverse lst))))))
; (defun swap-to-left (lst) 
;     (cond ((null lst) Nil)
;           (t (append (cdr lst) (cons (car lst) Nil)))))
; (print (swap-to-left '(a b c d)))
; (defun swap-to-right (lst)
;     (cond ((null lst) Nil)
;           (t (cons (car (last lst)) (remove-last lst)))))
; (print (swap-to-right '(a b c d)))
; задание 7 - done
; (defun elem-equal (el1 el2)
;     (and (equalp (car el1) (car el2)) (equalp (cdr el1) (cdr el2))))
; (defun elem-in-set (sett el)
;     (cond ((null sett) Nil)
;           ((elem-equal (car sett) el) t)
;           (t (elem-in-set (cdr sett) el))))
; (defun add-elem-in-set (sett el)
;     (cond ((elem-in-set sett el) sett)
;           (t (cons el sett))))
; (print (add-elem-in-set '((a . b) (c . d)) '(b . a)))
; задание 8 - done
; (defun mult-first-num-a (num lst) (cons (* num (car lst)) (cdr lst)))
; (print (mult-first-num-a 5 '(1 2 3)))
; (defun mult-first-num-b (num lst &optional (buf-lst Nil)) 
;     (cond ((null lst) buf-lst)
;           ((numberp (car lst)) (append buf-lst (cons (* num (car lst)) (cdr lst))))
;           (t (mult-first-num-b num (cdr lst) (append buf-lst (cons (car lst) Nil))))))
; (print (mult-first-num-b 5 '(1 2 3)))
; задание 9 - done
(defun get-between-ind (ind1 ind2 lst &optional (cnt 0) (res-lst Nil))
    (cond ((null lst) Nil)
          ((<= cnt ind1) (get-between-ind ind1 ind2 (cdr lst) (+ cnt 1)))
          ((< ind1 cnt ind2) (get-between-ind ind1 ind2 (cdr lst) (+ cnt 1)
            (append res-lst (cons (car lst) Nil))))
          (t res-lst)))

(defun get-between (num1 num2 lst &optional (res-lst Nil))
    (cond ((null lst) res-lst)
          ((< num1 (car lst) num2) (get-between num1 num2 (cdr lst) 
            (append res-lst (cons (car lst) Nil))))
          (t (get-between num1 num2 (cdr lst) res-lst))))

(defun insert-elem (lst elem &optional (before-lst Nil))
    (cond ((and (null lst) (not (null before-lst))) (append before-lst (cons elem Nil)))
          ((null lst) (cons elem Nil))
          ((< elem (car lst)) (append before-lst (cons elem Nil) lst))
          (t (insert-elem (cdr lst) elem (append before-lst (cons (car lst) Nil))))))
(defun sort-elem (lst &optional (res-lst Nil))
    (cond ((null lst) res-lst)
          (t (sort-elem (cdr lst) (insert-elem res-lst (car lst))))))

(defun select-between (ind1 ind2 lst)
    (cond ((null lst) Nil)
          ((> ind1 ind2) (sort-elem (get-between ind2 ind1 lst)))
          (t (sort-elem (get-between ind1 ind2 lst)))))
(print (select-between 3 10 '(8 12 3 9 1.0)))